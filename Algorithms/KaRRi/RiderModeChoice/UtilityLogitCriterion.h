#pragma once

#include "Algorithms/KaRRi/BaseObjects/Request.h"
#include "Algorithms/KaRRi/InputConfig.h"
#include "Algorithms/KaRRi/TimeUtils.h"
#include "UtilityLogit/Logit.h"
#include "UtilityLogit/utility.h"
#include "UtilityLogit/csvUtils.h"
#include "TransportMode.h"

namespace karri::mode_choice {

    constexpr char parametersFileContent[] =
#include "UtilityLogit/autogenerated_includable_parameters"
        ;

    using namespace karri::mode_choice::utility_logit;

    // Decides whether a rider accepts an assignment based on the request and the assignment finder response.
    // Computes simple utility function with default parameters and applies a logit model.
    class UtilityLogitCriterion {

    public:

        explicit UtilityLogitCriterion(const RouteState &routeState)
                : routeState(routeState),
                  logit(utility_logit::exampleUtilityFunction,
                        options,
                        loadParametersFromCSV<TransportMode, ModeParameters>(std::stringstream(parametersFileContent),
                                                                             stringToTransportMode, fromMap)) {}

        template<typename AsgnFinderResponseT>
        TransportMode chooseMode(const Request &req, const AsgnFinderResponseT &resp) const {
            using namespace time_utils;

            const double walkTravelTime = tenthsOfSecondsToMinutes(resp.odWalkingDist);
            const double privateCarTravelTime = tenthsOfSecondsToMinutes(resp.originalReqDirectDist);

            const auto &bestAsgn = resp.getBestAssignment();
            double taxiTravelTime = static_cast<double>(INFTY);
            double taxiWaitTime = static_cast<double>(INFTY);
            double taxiAccEgrTime = static_cast<double>(INFTY);
            if (bestAsgn.vehicle) {
                const auto depTimeAtPickup = getActualDepTimeAtPickup(bestAsgn, resp, routeState);
                const auto initialPickupDetour = calcInitialPickupDetour(bestAsgn, depTimeAtPickup, resp, routeState);
                const auto dropoffAtExistingStop = isDropoffAtExistingStop(bestAsgn, routeState);
                const auto arrTimeAtDropoff = getArrTimeAtDropoff(depTimeAtPickup, bestAsgn, initialPickupDetour,
                                                                  dropoffAtExistingStop, routeState);
                taxiTravelTime = tenthsOfSecondsToMinutes(arrTimeAtDropoff - depTimeAtPickup);
                taxiWaitTime = tenthsOfSecondsToMinutes(
                        depTimeAtPickup - req.requestTime - bestAsgn.pickup.walkingDist);
                taxiAccEgrTime = tenthsOfSecondsToMinutes(bestAsgn.pickup.walkingDist + bestAsgn.dropoff.walkingDist);
            }

            std::vector<Alternative<TransportMode>> entries = {
                    {TransportMode::Car,  Attributes{privateCarTravelTime, 0, 0}},
                    {TransportMode::Ped,  Attributes{walkTravelTime, 0, 0}},
                    {TransportMode::Taxi, Attributes{taxiTravelTime, taxiWaitTime, taxiAccEgrTime}}
            };
            return logit.select(entries);
        }

    private:

        static constexpr double tenthsOfSecondsToMinutes(const int timeInTenthsOfSeconds) {
            return static_cast<double>(timeInTenthsOfSeconds) / 600.0;
        }

        const RouteState &routeState;

        static const std::vector<TransportMode> options;
        const Logit<TransportMode, ModeParameters> logit;

    };

    // out of line definition of static member
    const std::vector<TransportMode> UtilityLogitCriterion::options = {TransportMode::Car, TransportMode::Ped,
                                                                       TransportMode::Taxi};

} // karri